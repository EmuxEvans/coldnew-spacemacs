#+TITLE: coldnew's emacs config
#+AUTHOR: Yen-Chin, Lee <coldnew>
#+email: coldnew.tw at gmail.com
#+STARTUP: overview indent align
#+BABEL: :cache yes
#+OPTIONS: ^:nil

# Badge
[[http://www.gnu.org/licenses/gpl-3.0.txt][https://img.shields.io/badge/license-GPL_3-green.svg?dummy]]
[[https://travis-ci.org/coldnew/coldnew-spacemacs][https://travis-ci.org/coldnew/coldnew-spacemacs.svg?branch=master]]

* About

This is my another emacs config, which is a totally rewrite version
based on top of [[https://github.com/syl20bnr/spacemacs][spacemacs]] and [[https://github.com/coldnew/coldnew-emacs][coldnew-emacs]] with [[http://en.wikipedia.org/wiki/Literate_programming][literate programming]]
in [[http://orgmode.org/][org-mode]] ,but use English to write this config instead.

Feal free to use it :).

*Hint*: before fork and hack my emacs config, take a look at [[file:init.el]]

** Install or testing this config

- First use git to download whole repo

  : git clone https://github.com/coldnew/coldnew-spacemacs.git

- Then use git submodule to download the spacemacs

  : git submodule init
  : git submodule update

- Befor trying starting emacs, you need to bootstrap with [[https://github.com/cask/cask][Cask]]

  : cask install

- If you don not put this repo on =~/.emacs.d=, you need to use following
  command to start emacs

  : emacs -q -l ~/coldnew-spacemacs/init.el

** Packages need to install in system (Optional)

Some extra packages need to install in system manually. These packages
are =optional= but can make my spacemacs work more nicely.

- Mac OSX

  #+BEGIN_SRC sh
    brew install the_silver_searcher
    brew install fasd
    brew install mu --with-emacs --HEAD
    brew install doxymacs
  #+END_SRC


- Gentoo Linux

  #+BEGIN_SRC sh
    emerge sys-apps/the_silver_searcher
    emerge app-shells/fasd
    USE="emacs" emerge net-mail/mu
    emerge  app-emacs/doxymacs
  #+END_SRC

* Package Management with Cask and Pallet

[[https://github.com/rdallasgray/pallet][Pallet]] is a wonderful little tool built on [[https://github.com/cask/cask][Cask]], a dependency
management tool for Emacs packages. Pallet adds automatic updating of
the =Caskfile= when packages are installed and deleted.

** Installing Cask

Just run this command in your terminal of choice:

#+BEGIN_SRC sh :tangle no
  $ curl -fsSkL https://raw.github.com/cask/cask/master/go | python
#+END_SRC

then add =~/.cask/bin= to your =PATH= so that you can use =cask=.

** Creating a Caskfile

For now, we just need a minimal =Cask= to get Pallet set up. Mine
looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  (source gnu)
  (source melpa)

  (depends-on "evil")
  (depends-on "f")
  (depends-on "s")
  (depends-on "dash")
  (depends-on "pallet")
  (depends-on "req-package")
#+END_SRC

Then run the following command in your =.emacs.d= directory to set up
[[https://github.com/rdallasgray/pallet][Pallet]].

#+BEGIN_SRC sh :tangle no
  cask install
#+END_SRC

** Initialize Cask

Finally, we add the following lines to our init file:

#+BEGIN_SRC emacs-lisp
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
#+END_SRC

** Initialize Pallet

Since we already install pallet via cask, we just need to use
following code to initialize pallet.

#+BEGIN_SRC emacs-lisp
  (require 'pallet)
  (pallet-mode t)
#+END_SRC

* Dependency Management with req-package

[[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
management tool. The documentation for =use-package= is immensely
helpful for figuring out how to describe package dependencies and
settings. =req-package= adds the =:require= keyword which allows us to
define dependencies between related packages.

** Initialize req-package

With the preceding process complete, we just need to add the following
line to our init file to begin using =req-package=:

#+BEGIN_SRC emacs-lisp
  (require 'req-package)
#+END_SRC

** Start loading packages in right order

To start loading packages in right order, we need to added following
in the last of emacs config.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package-finish)
#+END_SRC

You can take a look at [[*End%20of%20configuration][End of configuration]] section.

* Load Path

The variable =load-path= lists all the directories where Emacs should
look for Elisp files.

Though I use =Cask= as package management in my emacs, some local
packages like my own theme or others can't fetch by elpa need to add
to load-path, this will help emacs find them.

Following are my method to add directories to load-path ~recursively~,
this function also create directory to prevent directory not exist.

If you don't have any local elisp and all packages is mantain by cask
or elpa or spacemacs, you can skip following code.

#+BEGIN_SRC emacs-lisp
  ;; Add directories to emacs's `load-path' recursively.
  ;; if path does not exist, create directory.
  (let* ((lisp-dir '("local-lisp/" "theme/")))
    (dolist (lisp-path lisp-dir)
      (when (not (file-exists-p lisp-path))
        (make-directory (concat emacs-dir lisp-path) t))
      (let* ((load-dir (concat emacs-dir lisp-path))
             (default-directory load-dir))
        (setq load-path
              (append
               (let ((load-path (copy-sequence load-path)))
                 (append
                  (copy-sequence (normal-top-level-add-to-load-path '(".")))
                  (normal-top-level-add-subdirs-to-load-path)))
               load-path)))))
#+END_SRC
* Spacemacs

[[https://github.com/syl20bnr/spacemacs][Spacemacs]] is an emacs starterkit focus on [[https://gitorious.org/evil/pages/Home][Evil]], which emulate vim
keymap on Emacs.

I make my emacs on top of spacemacs since I also use vim keymap.

In my config file, the original =~/.spacemacs= file has move to
=spacemacs.el= under emacs-dir folder, I also advice spacemacs funtion
to prevent orphan packages deleted by spacemacs.

After all spacemacs init done, switch back to =*scratch*= buffer.

#+BEGIN_SRC emacs-lisp
  ;; Make spacemacs not remove my orphan packages.
  (defadvice configuration-layer/delete-orphan-packages (around null-func activate)
    "Overwrite the spacemacs's `configuration-layer/delete-orphan-packages'
  to make it not remove any orphan packages.")

  ;; Make a fake entry point for spacemacs, also modify the
  ;; `user-emacs-directory' temporary to mislead spacemacs real emacs
  ;; directory.
  (let* ((spacemacs-dir
          (directory-file-name (concat emacs-dir "spacemacs")))
         (spacemacs-init
          (concat (file-name-as-directory spacemacs-dir) "init.el"))
         (user-emacs-directory (file-name-directory spacemacs-init)))

    ;; load my config instead of make spacemacs load ~/.spacemacs
    (load (concat emacs-dir "spacemacs.el"))

    ;; Initial spacemacs, our emacs run on top of it
    (load spacemacs-init))

  ;; After spacemacs loading finished, switch back to `*scratch*' buffer
  (switch-to-buffer "*scratch*")
#+END_SRC

* Languages and Encodings

Since current Emacs default run on UTF-8, it's no need to setup the
encoding.

For language, though Traditional Chinese is my mothertone, I still
prefer use =en_US= to display time info.

#+BEGIN_SRC emacs-lisp
  (setq system-time-locale "en_US" )
#+END_SRC

* Packages

** 4clojure

[[https://github.com/losingkeys/4clojure.el][4clojure.el]] let you open and evaluate [[http://www.4clojure.com/][4clojure]] questions.

#+BEGIN_SRC emacs-lisp
  (req-package 4clojure)
#+END_SRC

** ascii

[[http://www.emacswiki.org/emacs/AsciiMode][Ascii]] provides a way to display ASCII code on a window, that is,
display in another window an ASCII table highlighting the current
character code.

#+BEGIN_SRC emacs-lisp
  (req-package ascii
    :init
    (progn
      ;; ascii-toggle
      (defun ascii-toggle ()
        "Toggle ascii-mode."
        (interactive)
        (if (not (ascii-off)) (ascii-on)))

      ;; alias ascii to ascii-toggle
      (defalias 'ascii 'ascii-toggle)))
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

#+BEGIN_SRC emacs-lisp
  (req-package iedit)
#+END_SRC

** pangu-spacing

[[https://github.com/coldnew/pangu-spacing][pangu-spcing]] is an minor-mode to auto add =space= between Chinese and
English characters. Note that these white-space characters are not
really added to the contents, it just like to do so.

#+BEGIN_SRC emacs-lisp
  (req-package pangu-spacing
    :init
    (progn
      ;; Always insert `real' space in org-mode.
      (add-hook 'org-mode-hook
                '(lambda ()
                   (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))
      ))
#+END_SRC

** lusty-explorer

[[https://github.com/sjbach/lusty-emacs][lusty-explorer]] s a fast and responsive way to manage files and
buffers. It includes both a filesystem explorer and a buffer switcher
through a common interface.

#+BEGIN_SRC emacs-lisp
  (req-package lusty-explorer
    :init
    (progn
      ;; use lusty-explorer method to do completion
      (eval-after-load "helm-mode"
        '(progn
           (add-to-list 'helm-completing-read-handlers-alist '(lusty-file-explorer . nil))
           (add-to-list 'helm-completing-read-handlers-alist '(lusty-buffer-explorer . nil)))))
    :config
    (progn
      (bind-key "RET" 'lusty-select-current-name lusty-mode-map)))
#+END_SRC

** sx

[[https://github.com/vermiculus/sx.el/][SX]] is a full featured Stack Exchange mode for GNU Emacs 24+. Using the
official API, it provides a versatile experience for the Stack
Exchange network within Emacs itself.

#+BEGIN_SRC emacs-lisp
  (req-package sx :require sx-load)
#+END_SRC

** hungry-delete

[[https://github.com/nflath/hungry-delete][hungry-delete]] borrows hungry deletion from =cc-mode=, which will
causes deletion to delete all whitespace in the direction you are deleting.

#+BEGIN_SRC emacs-lisp
  (req-package hungry-delete
    :init (global-hungry-delete-mode))
#+END_SRC

** rainbow-mode

[[https://julien.danjou.info/projects/emacs-packages][rainbow-mode]] s a minor mode for Emacs which displays strings
representing colors with the color they represent as background.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-mode)
#+END_SRC

** doxymacs

#+BEGIN_SRC emacs-lisp
  (req-package doxymacs
    :config
    (add-hook 'prog-mode-hook '(lambda () (doxymacs-mode))))
#+END_SRC

* Interactive Commands

In emacs, we can use =M-x= to execute interactive commands, I
implement some of them to make my emacs more easy to use.

** Buffers

*** Kill all buffers except *scratch* buffer

Sometimes I just want to kill all buffers, this command will kill all
of them and make =*scratch*= buffer alone.

#+BEGIN_SRC emacs-lisp
  (defun nuke-all-buffers ()
    "Kill all buffers, leaving *scratch* only."
    (interactive)
    (mapcar (lambda (x) (kill-buffer x)) (buffer-list))
    (delete-other-windows))
#+END_SRC

*** Make emacs can always save buffers (even if file is not modified)

The default command *save-buffer* will not really save file when it
untouched, use this command can let me force save file even if file is
not modified.

#+BEGIN_SRC emacs-lisp
  (defun save-buffer-always ()
    "Save the buffer even if it is not modified."
    (interactive)
    (set-buffer-modified-p t)
    (save-buffer))
#+END_SRC

** Edit (Insert/Remove)

*** Insert U200B char

=<U200B>= character is a =zero width space character= which is nice to
use under org-mode.

For more info, please see: [[https://lists.gnu.org/archive/html/emacs-orgmode/2012-09/msg00155.html][suggestion for org-emphasis-regexp-components: *U*nited *N*ations]]

#+BEGIN_SRC emacs-lisp
  (defun insert-U200B-char ()
    "Insert <U200B> char, this character is nice use in org-mode."
    (interactive)
    (insert "\ufeff"))
#+END_SRC

* Theme

I always use dark theme for coding, [[https://github.com/kuanyui/moe-theme.el][moe-theme]] is a good start point,
it's bright and has good default faces for most modes. It also has
dark and light versions, which is convenient.

However, I always want to customize everything on my own, so I rebuild
another emacs theme called =coldnew-theme-night= and
=coldnew-theme-day= which are based on [[https://github.com/kuanyui/moe-theme.el][moe-theme]], you can find them at
[[file:theme/coldnew-theme.el]].

Before use emacs's =load-theme= function, I advise it to it fully
unload previous theme before loading a new one.

#+BEGIN_SRC emacs-lisp
  ;; Make `load-theme' fully unload previous theme before loading a new
  ;; one.
  (defadvice load-theme
      (before theme-dont-propagate activate)
    (mapc #'disable-theme custom-enabled-themes))

  ;; use coldnew-theme-night by default
  (req-package coldnew-theme :init (coldnew-theme-night))
#+END_SRC

* Editors

Why emacs config has an editor section, doesn't means emacs is not an
editor ? Yes, Emacs is an OS :)

I put some editor/IDE relative functions and packages here.

** Line Numbers

In most case, I'll make line numers display globally by =linum=.

#+BEGIN_SRC emacs-lisp
  (req-package linum :init (global-linum-mode 1))
#+END_SRC

Disable line number in some mode, for example, since =org-mode= can
has many lines, it's not recommand to enable linum-mode.

I use =linum-off= to disable some mode.

#+BEGIN_SRC emacs-lisp
  (req-package linum-off
    :config
    (progn
      (setq linum-disabled-mode-list
            '(eshell-mode shell-mode term-mode erc-mode compilation-mode
                          woman-mode w3m-mode calendar-mode org-mode
                          ))))
#+END_SRC

** Colorfy delimters

[[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] is a "rainbow parentheses"-like mode which
highlights delimiters such as parentheses, brackets or braces
according to their depth. Each successive level is highlighted in a
different color. This makes it easy to spot matching delimiters,
orient yourself in the code, and tell which statements are at a given
depth.

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Hoghlight numbers

[[https://github.com/Fanael/highlight-numbers][highlight-numbers]]

#+BEGIN_SRC emacs-lisp
  (req-package highlight-numbers
    :init
    (add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC

** Blocking syntax highlight

FIXME: buggy, can't really use
#+BEGIN_SRC emacs-lisp :tangle no
  (req-package rainbow-blocks
    :init (global-rainbow-blocks-mode t))
#+END_SRC

** Vim Emulation

#+BEGIN_SRC emacs-lisp
  (req-package evil
    :require (undo-tree)
    :ensure evil
    :init (evil-mode t)
    :config
    (progn
      ;; Bind all emacs-state key to insert state
      (setcdr evil-insert-state-map nil)
      (define-key evil-insert-state-map
        (read-kbd-macro evil-toggle-key) 'evil-emacs-state)

      ;; Make sure `ESC' in insert-state will call `evil-normal-state'
      (define-key evil-insert-state-map [escape] 'evil-normal-state)

      ;; Make all emacs-state buffer become to insert-state
      (dolist (m evil-emacs-state-modes)
        (add-to-list 'evil-insert-state-modes m))
      ))
#+END_SRC

** En/Decrypt files by [[http://emacswiki.org/emacs/EasyPG][EasyPG]]

#+BEGIN_SRC emacs-lisp
  (req-package epa-file
    :init (epa-file-enable)
    :config
    (progn
      ;; Control whether or not to pop up the key selection dialog.
      (setq epa-file-select-keys 0)
      ;; Cache passphrase for symmetric encryption.
      (setq epa-file-cache-passphrase-for-symmetric-encryption t)))
#+END_SRC

** Create *scratch* automatically

#+BEGIN_SRC emacs-lisp
  ;; Create *scratch* automatically
  (run-with-idle-timer 1 t
                       '(lambda ()
                          (unless (get-buffer "*scratch*")
                            (with-current-buffer (get-buffer-create "*scratch*")
                              (lisp-interaction-mode)))))
#+END_SRC

** Project management with projectile

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :interpreter ("projectile" . projectil-mode))
#+END_SRC

** Completion with Company mode

[[http://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidates.

#+BEGIN_SRC emacs-lisp
  (req-package company
    :require (company-c-headers company-quickhelp)
    :config
    (progn
      ;; company-c-headers
      (add-to-list 'company-backends 'company-c-headers)
      ;; Enable quickhelp doc window
      (company-quickhelp-mode 1)

      ;; Keybinding
      (bind-key "C-g" 'company-abort company-active-map)
      (bind-key "C-n" 'company-select-next company-active-map)
      (bind-key "C-p" 'company-select-nextprevious company-active-map)
      (bind-key "TAB" 'company-complete-selection company-active-map)
      (bind-key "<tab>" 'company-complete-selection company-active-map)
      ))
#+END_SRC

* Terminal Emulator

** Eshell

eshell is not really a system shell, it's written in pure lisp. What I
like is it fully integrated with emacs.

*** Support for multi-eshell instance

#+BEGIN_SRC emacs-lisp
  (req-package multi-eshell
    :require eshell
    :config
    (progn
      (setq multi-eshell-shell-function '(eshell))
      (setq multi-eshell-name "*eshell*")))
#+END_SRC

*** Add autojump command

[[http://www.emacswiki.org/emacs/EshellAutojump][Eshell Autojump]] is an [[https://github.com/joelthelion/autojump][autojump]] like command written in pure elisp,
which add a =j= command to let you jump to folder you has been access.

#+BEGIN_SRC emacs-lisp
  (req-package eshell-autojump :require eshell)
#+END_SRC

* Window Management

** Maximized window after emac start

#+BEGIN_SRC emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

** winner-mode

#+BEGIN_SRC emacs-lisp
  (req-package winner
    :config
    (progn
      ;; I use my own keymap for winner-mode
      (setq winner-dont-bind-my-keys t)
      ;; Start winner-mode globally
      (winner-mode t)))
#+END_SRC

* Programming Languages

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (req-package lisp-mode
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.el$" . emacs-lisp-mode))
      (add-to-list 'auto-mode-alist '("Cask" . emacs-lisp-mode))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package eldoc
    :init
    (add-hook 'emacs-lisp-mode-hook
              '(lambda ()
                 ;; enable eldoc
                 (turn-on-eldoc-mode)
                 ;; fix for paredit if exist
                 (eval-after-load 'paredit
                   '(progn
                      (eldoc-add-command 'paredit-backward-delete
                                         'paredit-close-round))))))
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (req-package org
    :require (org-crypt org-mac-link org-magit)
    :mode ("\\.org\\'" . org-mode)
    :config
    (progn
      (add-hook 'org-mode-hook
                '(lambda ()
                   ;; fontify source code
                   (setq org-src-fontify-natively t)
                   ))
      ))
#+END_SRC

** SSH Config

#+BEGIN_SRC emacs-lisp
  (req-package ssh-config-mode
    :init
    (progn
      (add-to-list 'auto-mode-alist '(".ssh/config\\'"       . ssh-config-mode))
      (add-to-list 'auto-mode-alist '("sshd?_config\\'"      . ssh-config-mode))
      (add-to-list 'auto-mode-alist '("known_hosts\\'"       . ssh-known-hosts-mode))
      (add-to-list 'auto-mode-alist '("authorized_keys2?\\'" . ssh-authorized-keys-mode))
      (add-hook 'ssh-config-mode-hook 'turn-on-font-lock)))
#+END_SRC

** CMake

#+BEGIN_SRC emacs-lisp
  (req-package cmake-font-lock
    :require (cmake-mode)
    :config
    (progn
      (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)))
#+END_SRC

** C/C++

#+BEGIN_SRC emacs-lisp
  (req-package c-eldoc
    :config
    (progn
      (add-hook 'c-mode-common-hook
                '(lambda ()
                   (setq c-eldoc-includes "`pkg-config gtk+-3.0 --cflags --libs` -I./ -I../")
                   (c-turn-on-eldoc-mode)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package cwarn
    :init (add-hook 'c-mode-common-hook '(lambda () (cwarn-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (req-package cpputils-cmake
    :config
    (progn
      (add-hook 'c-mode-common-hook
                (lambda () (when (derived-mode-p 'c-mode 'c++-mode) (cppcm-reload-all))))))
#+END_SRC

** Graphviz

#+BEGIN_SRC emacs-lisp
  (req-package graphviz-dot-mode
    :init (defalias 'dot-mode 'graphviz-dot-mode))
#+END_SRC

** javascript

#+BEGIN_SRC emacs-lisp
  (req-package js2-mode
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      (setq js2-highlight-level 3)
      ))
#+END_SRC

** QML

#+BEGIN_SRC emacs-lisp
  (req-package qml-mode
    :init (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode)))
#+END_SRC

** SCSS

#+BEGIN_SRC emacs-lisp
  (req-package scss-mode
    :init (add-to-list 'auto-mode-alist '("\\.scss$" . scss-mode))
    :config
    (progn
      ;; dont' build scss to css after save file
      (setq scss-compile-at-save nil)))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (req-package css-mode
    :init (add-to-list 'auto-mode-alist '("\\.css$" . css-mode)))
#+END_SRC

** Less

#+BEGIN_SRC emacs-lisp
  (req-package less-css-mode
    :init (add-to-list 'auto-mode-alist '("\\.less$" . less-css-mode)))
#+END_SRC

* Keybinding

** Generate keymap from org-mode table

org-mode  is really nice for literature programmering, I can use it to
generate keybing via table, just use following functions:


#+NAME: define-keys
#+BEGIN_SRC emacs-lisp :results output :tangle no :exports none :colnames nil
  (mapcar (lambda (l)
            (let* ((key (nth 0 l))
                   (def (format "define-key %s (kbd \"%s\")" map key))
                   (command (nth 1 l)))
              (princ (format "(%s '%s)\n" def command))))
          ;; remove all `hline' tag first line in list
          (cdr (remove 'hline keys)))
#+END_SRC

** Spacemacs Map

** Normal State

#+TBLNAME: global-evil-normal
| Key     | Command             | description                          |
|---------+---------------------+--------------------------------------|
| M-[     | winner-undo         | switch back to earlier window layout |
| M-]     | winner-redo         | restore resent window layout         |
| C-x C-q | read-only-mode      | toggle read-only-mode                |
| C-x C-s | save-buffer-always  | Always save buffer even not modified |
| C-x C-f | lusty-file-explorer | Use lusty-file-explorer to find-file |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
    <<define-keys(map="evil-normal-state-map", keys=global-evil-normal)>>
#+END_SRC

** Insert State

#+TBLNAME: global-evil-insert
| Key      | Command                      | description                          |
|----------+------------------------------+--------------------------------------|
| C-n      | evil-next-line               | next-line                            |
| C-p      | evil-previous-line           | previous-line                        |
| C-;      | iedit-mode                   | Quicklly modify all same words       |
| M-[      | winner-undo                  | switch back to earlier window layout |
| M-]      | winner-redo                  | restore resent window layout         |
| C-o      | evil-execute-in-normal-state | Temporary switch to Normal sate      |
| C-d      | hungry-delete-forward        | forward delete with hungry-mode      |
| C-l      | hungry-delete-backward       | backward delete with hungru-mode     |
| <delete> | hungry-delete-backward       | backward delete with hungru-mode     |
| C-x C-q  | read-only-mode               | toggle read-only-mode                |
| C-x C-s  | save-buffer-always           | Always save buffer even not modified |
| M-<SPC>  | insert-U200B-char            | Insert <U200B> character             |
| s-<SPC>  | insert-U200B-char            | Insert <U200B> character             |
| C-x C-f  | lusty-file-explorer          | Use lusty-file-explorer to find-file |
| C-x C-n  | company-complete             | Complete with company-mode           |

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
    <<define-keys(map="evil-insert-state-map", keys=global-evil-insert)>>
#+END_SRC

* End of configuration

At long last we need only call the following function to send
=req-package= on its merry way.

#+BEGIN_SRC emacs-lisp
  (req-package-finish)
#+END_SRC
